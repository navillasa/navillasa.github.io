<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-08-19T04:23:24-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Natalie Villasana</title><subtitle>DevOps Engineer | navillasa.dev</subtitle><author><name>Natalie Villasana</name><email>navillasa.dev@gmail.com</email></author><entry><title type="html">The K8s Doctor, or How I Learned to Stop Worrying and Fix 502s</title><link href="http://localhost:4000/blog/debugging-502-errors/" rel="alternate" type="text/html" title="The K8s Doctor, or How I Learned to Stop Worrying and Fix 502s" /><published>2025-08-18T00:00:00-04:00</published><updated>2025-08-18T00:00:00-04:00</updated><id>http://localhost:4000/blog/debugging-502-errors</id><content type="html" xml:base="http://localhost:4000/blog/debugging-502-errors/">## The Problem Pattern

Throughout this project, I've hit the same issue repeatedly:
- **Frontend** looking for `dev-backend-service` instead of `prod-backend-service`
- **ArgoCD ingress** using port 443 instead of port 80
- **Vault** connection errors due to service discovery issues
- **External Secrets** pointing to wrong Vault paths

**The common thread**: **502 Bad Gateway errors caused by communication mismatches.**

## The 502 Error: What It Really Means

```
502 Bad Gateway = &quot;I can reach something, but it's not responding correctly&quot;
```

**This is different from:**
- **404**: &quot;I can't find anything at this path&quot;
- **503**: &quot;Service is temporarily unavailable&quot;  
- **Connection timeout**: &quot;I can't reach anything at all&quot;

**502 specifically means**: The proxy/load balancer reached a backend, but the backend response was invalid.

## The Systematic Debugging Approach

### Step 1: Identify the Communication Chain

Every 502 has a path like this:
```
Client → Load Balancer → Service → Pod
```

Find where it breaks by checking each link.

### Step 2: Check Backend Health in Load Balancer

```bash
# Get detailed ingress status
kubectl describe ingress &lt;ingress-name&gt; -n &lt;namespace&gt;

# Look for backend health status
# Example output:
ingress.kubernetes.io/backends: {
  &quot;k8s1-backend-service-443&quot;:&quot;UNHEALTHY&quot;  # ← The smoking gun!
}
```

**Key indicators:**
- `UNHEALTHY` = Backend isn't responding on expected port/protocol
- `HEALTHY` = Backend is fine, look elsewhere

## Pro Tips for Faster Debugging

### 1. **Use Port-Forward for Direct Testing**
```bash
# Bypass ingress/service and test pod directly
kubectl port-forward pod/&lt;pod-name&gt; 8080:8080
curl http://localhost:8080/health
```

### 2. **Check Multiple Namespaces**
```bash
# Service in wrong namespace is super common
kubectl get services --all-namespaces | grep &lt;service-name&gt;
```

The key insight: Most 502 errors are configuration mismatches, not infrastructure failures. A systematic approach beats random troubleshooting every time.</content><author><name>Natalie Villasana</name></author><category term="kubernetes" /><category term="debugging" /><category term="devops" /><category term="kubernetes" /><category term="502-errors" /><category term="troubleshooting" /><category term="nginx" /><category term="ingress" /><summary type="html">The Problem Pattern</summary></entry><entry><title type="html">Why I Didn’t Make Vault an ArgoCD Application</title><link href="http://localhost:4000/blog/vault-gitops/" rel="alternate" type="text/html" title="Why I Didn’t Make Vault an ArgoCD Application" /><published>2025-08-18T00:00:00-04:00</published><updated>2025-08-18T00:00:00-04:00</updated><id>http://localhost:4000/blog/vault-gitops</id><content type="html" xml:base="http://localhost:4000/blog/vault-gitops/">&lt;h2 id=&quot;the-question&quot;&gt;The Question&lt;/h2&gt;

&lt;p&gt;During the GitOps implementation, I considered whether HashiCorp Vault should be managed as an ArgoCD application alongside the other workloads. This post explains why I chose to keep Vault outside of the GitOps workflow.&lt;/p&gt;

&lt;h2 id=&quot;the-temptation&quot;&gt;The Temptation&lt;/h2&gt;

&lt;p&gt;At first glance, managing Vault through ArgoCD seems &lt;em&gt;pretty&lt;/em&gt; cool:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Consistency&lt;/strong&gt;: Everything else is managed by ArgoCD&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Version Control&lt;/strong&gt;: Vault configuration tracked in Git&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Declarative&lt;/strong&gt;: Infrastructure as Code principles&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Automation&lt;/strong&gt;: Automated deployments and updates&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-bootstrap-problem&quot;&gt;The Bootstrap Problem&lt;/h2&gt;

&lt;p&gt;The fundamental issue is a &lt;strong&gt;circular dependency&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;┌─────────────┐    needs    ┌──────────────────┐    needs    ┌───────────┐
│   ArgoCD    │ ──────────► │ External Secrets │ ──────────► │   Vault   │
│             │             │    Operator      │             │           │
└─────────────┘             └──────────────────┘             └───────────┘
       ▲                                                            │
       │                    manages (if GitOps)                     │
       └────────────────────────────────────────────────────────────┘
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;The problem&lt;/strong&gt;: If ArgoCD manages Vault, then ArgoCD depends on Vault (for secrets) which depends on ArgoCD (for deployment). This creates an unresolvable bootstrap dependency.&lt;/p&gt;

&lt;h2 id=&quot;infrastructure-layers&quot;&gt;Infrastructure Layers&lt;/h2&gt;

&lt;p&gt;I solved this by establishing clear &lt;strong&gt;infrastructure layers&lt;/strong&gt;:&lt;/p&gt;

&lt;h3 id=&quot;layer-0-foundation-infrastructure&quot;&gt;Layer 0: Foundation Infrastructure&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;GKE Cluster&lt;/strong&gt; (Terraform)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Static IPs&lt;/strong&gt; (Terraform)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Vault&lt;/strong&gt; (kubectl apply)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;External Secrets Operator&lt;/strong&gt; (Helm)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;layer-1-gitops-platform&quot;&gt;Layer 1: GitOps Platform&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ArgoCD&lt;/strong&gt; (kubectl apply)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ClusterSecretStore&lt;/strong&gt; (ArgoCD)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;layer-2-applications&quot;&gt;Layer 2: Applications&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;tv-dashboard-dev&lt;/strong&gt; (ArgoCD)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;tv-dashboard-prod&lt;/strong&gt; (ArgoCD)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;monitoring-stack&lt;/strong&gt; (ArgoCD)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;alternative-approaches-considered&quot;&gt;Alternative Approaches Considered&lt;/h2&gt;

&lt;h3 id=&quot;1-manual-sync-only&quot;&gt;1. Manual Sync Only&lt;/h3&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# vault-app.yaml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;syncPolicy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;automated&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;null&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# No auto-sync to avoid bootstrap issues&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Pros&lt;/strong&gt;: Vault config in Git&lt;br /&gt;
&lt;strong&gt;Cons&lt;/strong&gt;: Manual intervention required, defeats GitOps automation&lt;/p&gt;

&lt;h3 id=&quot;2-app-of-apps-pattern&quot;&gt;2. App-of-Apps Pattern&lt;/h3&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# bootstrap-app.yaml - deployed manually&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Manages vault-app.yaml and argocd-apps.yaml&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Pros&lt;/strong&gt;: Complete GitOps coverage&lt;br /&gt;
&lt;strong&gt;Cons&lt;/strong&gt;: Complex bootstrap sequence, harder to debug&lt;/p&gt;

&lt;h3 id=&quot;3-external-vault&quot;&gt;3. External Vault&lt;/h3&gt;
&lt;p&gt;Use a managed secret service (Google Secret Manager, AWS Secrets Manager)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pros&lt;/strong&gt;: No bootstrap problem, less operational overhead&lt;br /&gt;
&lt;strong&gt;Cons&lt;/strong&gt;: Vendor lock-in, less learning value for this project&lt;/p&gt;

&lt;h2 id=&quot;the-decision-keep-vault-outside-gitops&quot;&gt;The Decision: Keep Vault Outside GitOps&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Reasons&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Operational Simplicity&lt;/strong&gt;: Vault is foundational infrastructure that should be stable and simple to manage&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Recovery Scenarios&lt;/strong&gt;: If ArgoCD fails, we can still access Vault to recover secrets&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Bootstrap Clarity&lt;/strong&gt;: Clear separation between foundation and application layers&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Production Patterns&lt;/strong&gt;: Many organizations treat secret management as Layer 0 infrastructure&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;production-considerations&quot;&gt;Production Considerations&lt;/h2&gt;

&lt;p&gt;In production environments, you might see:&lt;/p&gt;

&lt;h3 id=&quot;at-large-organizations&quot;&gt;At Large Organizations&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Dedicated Vault clusters&lt;/strong&gt; managed by platform teams&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Vault-as-a-Service&lt;/strong&gt; provided to application teams&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Manual deployment&lt;/strong&gt; with infrastructure automation (Terraform)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;at-cloud-native-shops&quot;&gt;At Cloud-Native Shops&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Managed secret services&lt;/strong&gt; (AWS Secrets Manager, etc.)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;External Secrets Operator&lt;/strong&gt; connecting to cloud providers&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;No self-hosted Vault&lt;/strong&gt; at all&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;in-gitops-purist-repos&quot;&gt;In GitOps Purist Repos&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Everything in Git&lt;/strong&gt; including Vault&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Complex bootstrap procedures&lt;/strong&gt; with operator dependencies&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Acceptance of operational complexity&lt;/strong&gt; for consistency&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;key-takeaway&quot;&gt;Key Takeaway&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Not everything needs to be in GitOps.&lt;/strong&gt; The right architectural boundary depends on:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Operational complexity&lt;/strong&gt; vs &lt;strong&gt;consistency benefits&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Bootstrap dependencies&lt;/strong&gt; and &lt;strong&gt;recovery scenarios&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Team structure&lt;/strong&gt; and &lt;strong&gt;operational expertise&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Compliance requirements&lt;/strong&gt; and &lt;strong&gt;audit trails&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For my TV Dashboard project, keeping Vault as foundational infrastructure provided the right balance of simplicity and functionality while still demonstrating modern secret management practices.&lt;/p&gt;

&lt;h2 id=&quot;what-i-learned&quot;&gt;What I Learned&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Architectural boundaries matter&lt;/strong&gt; - not every tool fits every pattern&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Bootstrap dependencies&lt;/strong&gt; are real constraints in system design&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Operational simplicity&lt;/strong&gt; often trumps theoretical consistency&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Production patterns&lt;/strong&gt; should inform learning project decisions&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The goal isn’t to GitOps-ify everything — it’s to build systems that are &lt;strong&gt;reliable, maintainable, and appropriate for their context&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;This decision reflects my specific context and learning goals. Your environment may have different constraints and requirements.&lt;/em&gt;&lt;/p&gt;</content><author><name>Natalie Villasana</name></author><category term="kubernetes" /><category term="vault" /><category term="gitops" /><category term="argocd" /><category term="devops" /><category term="kubernetes" /><category term="vault" /><category term="gitops" /><category term="argocd" /><category term="devops" /><category term="design" /><summary type="html">The Question</summary></entry></feed>